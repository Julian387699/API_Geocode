import streamlit as st
import pandas as pd
import time
from io import BytesIO
from geopy.geocoders import Nominatim
from geopy.exc import GeocoderTimedOut, GeocoderUnavailable
import os
import requests

# Cl√© LocationIQ
LOCATIONIQ_API_KEY = "pk.f77db56ba31235d07e1a1d045dc501de"

st.set_page_config(page_title="G√©ocodeur d'adresses", layout="centered")
st.title("G√©ocodeur d'adresses ‚Äì COLAS Belgique")

uploaded_file = st.file_uploader("Importer un fichier Excel", type=[".xls", ".xlsx"])

if uploaded_file:
    try:
        df = pd.read_excel(uploaded_file, dtype=str)
        st.success("Fichier charg√© avec succ√®s")

        colonnes = df.columns.tolist()
        col_adresse = st.selectbox("Colonne contenant les adresses", colonnes)
        col_entreprise = st.selectbox("Colonne contenant le nom de l‚Äôentreprise", colonnes)

        if st.button("Lancer le g√©ocodage"):
            geolocator = Nominatim(user_agent="streamlit_geocoder_colas")

            # --- Nettoyage adresse ---
            def nettoyer_adresse(adresse):
                if isinstance(adresse, str):
                    mots_a_supprimer = ["Internal Postal Box", "Bte", "Case postale", "(Biz)"]
                    for mot in mots_a_supprimer:
                        adresse = adresse.replace(mot, "")
                    adresse = adresse.replace("B ", "").strip()
                    if not adresse.lower().endswith("belgique"):
                        adresse += ", Belgique"
                    return adresse
                return ""

            # --- Nominatim avec retries ---
            def geocode_nominatim(adresse, retries=2):
                try:
                    location = geolocator.geocode(adresse, timeout=10)
                    if location:
                        return round(location.latitude, 6), round(location.longitude, 6)
                except (GeocoderTimedOut, GeocoderUnavailable):
                    if retries > 0:
                        time.sleep(1)
                        return geocode_nominatim(adresse, retries-1)
                except Exception as e:
                    st.write(f"Erreur Nominatim: {e}")
                return None, None

            # --- LocationIQ ---
            def geocode_locationiq(adresse):
                try:
                    url = "https://eu1.locationiq.com/v1/search"
                    params = {
                        "key": LOCATIONIQ_API_KEY,
                        "q": adresse,
                        "format": "json",
                        "limit": 1
                    }
                    response = requests.get(url, params=params)
                    data = response.json()
                    if isinstance(data, list) and len(data):
                        lat = float(data[0]['lat'])
                        lon = float(data[0]['lon'])
                        return round(lat, 6), round(lon, 6)
                except:
                    pass
                return None, None

            # --- Cache pour √©viter les doublons ---
            @st.cache_data
            def geocode_cache(adresse):
                lat, lon = geocode_locationiq(adresse)
                source = "LocationIQ"
                if lat is None or lon is None:
                    lat, lon = geocode_nominatim(adresse)
                    source = "Nominatim" if lat and lon else "√âchec"
                return lat, lon, source

            # --- Boucle principale ---
            latitudes, longitudes, adresses_finales, sources = [], [], [], []
            progress = st.progress(0)
            total = len(df)

            for i in range(total):
                adresse_orig = str(df.at[i, col_adresse])
                entreprise = str(df.at[i, col_entreprise]).strip()
                st.write(f"G√©ocodage en cours ({i+1}/{total}) : {adresse_orig}")

                adresse_utilisee = nettoyer_adresse(adresse_orig)
                lat, lon, source = geocode_cache(adresse_utilisee)

                # Fallback sur entreprise si adresse √©choue
                if (lat is None or lon is None) and entreprise:
                    adresse_alt = nettoyer_adresse(entreprise)
                    lat, lon, source = geocode_cache(adresse_alt)
                    if lat and lon:
                        adresse_utilisee = adresse_alt
                        source = f"Fallback entreprise ({source})"

                adresses_finales.append(adresse_utilisee)
                latitudes.append(lat)
                longitudes.append(lon)
                sources.append(source)

                progress.progress((i + 1) / total)

            # --- R√©sultats ---
            df[col_adresse] = adresses_finales
            df["Latitude"] = latitudes
            df["Longitude"] = longitudes
            df["Source g√©ocodage"] = sources

            st.success("‚úÖ G√©ocodage termin√©")
            st.dataframe(df.head())

            # Affichage des √©checs
            df_echec = df[df["Source g√©ocodage"] == "√âchec"]
            if not df_echec.empty:
                st.warning("Certaines adresses n'ont pas pu √™tre g√©ocod√©es :")
                st.dataframe(df_echec[[col_adresse, col_entreprise]])

            # Nettoyage colonne source
            df = df.drop(columns=["Source g√©ocodage"], errors="ignore")

            # Formatage dates
            colonnes_date = ["Date d√©but", "Date fin"]
            for col in colonnes_date:
                if col in df.columns:
                    df[col] = pd.to_datetime(df[col], errors='coerce').dt.strftime("%Y-%m-%d")

            # Export XLSX
            original_name = os.path.splitext(uploaded_file.name)[0]
            final_filename = f"{original_name}_compl√©t√©.xlsx"
            output = BytesIO()
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                df.to_excel(writer, index=False)
            output.seek(0)

            st.download_button(
                label="üì• T√©l√©charger le fichier XLSX compl√©t√©",
                data=output,
                file_name=final_filename,
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )

    except Exception as e:
        st.error(f"Erreur lors du traitement : {e}")
